<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Module Platform Builder</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f7fa;
      color: #333;
      margin: 2rem;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 2rem;
      text-align: center;
    }

    .controls-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .input-group, .button-group {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .input-group label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1rem;
    }

    input[type='file'] {
      display: none;
    }

    .file-label, .btn {
      padding: 0.6rem 1.4rem;
      background-color: #007bff;
      color: #fff;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      border: none;
      transition: background 0.3s;
    }

    .btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .btn:hover:not(:disabled), .file-label:hover {
      background-color: #0056b3;
    }

    input[type='number'] {
      width: 5rem;
      padding: 0.4rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      text-align: center;
    }

    .status {
      font-size: 0.95rem;
      color: #555;
      text-align: center;
      margin: 1rem 0;
    }

    .result-grid, .row-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
    }

    .result-card {
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 0.5rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .result-card img {
      max-width: 280px;
      max-height: 200px;
      border: 1px solid #ccc;
      margin-bottom: 0.5rem;
    }

    .group-block {
      width: 100%;
      margin-bottom: 2rem;
    }

    .group-label {
    text-align: center;
    font-size: 1.3rem;
    font-weight: bold;
    margin: 1rem 0;
    }

    #groupChart {
      display: none;
      margin: 2rem auto;
      max-width: 600px;
    }
  </style>
</head>
<body>
  <h1>Module Platform Builder</h1>

  <div class="controls-container">
    <div class="button-group">
    <label class="file-label" for="fileInput">Upload Data</label>
    <input type="file" id="fileInput" accept=".csv" />
    <button id="connectBtn" class="btn">Connect Graph DB</button>
    </div>

    <p id="statusMsg" class="status">Awaiting file.</p>

    <div class="input-group">
      <label>Room Count: <input type="number" id="vcountInput" value="4" min="1" /></label>
      <label>Max Width: <input type="number" id="maxWidthInput" step="0.1" value="2.5" min="0" /></label>
      <label>Compactness Threshold: <input type="number" id="ratioInput" step="0.01" value="0.3" min="0" max="1" /></label>
      <label>Min Support: <input type="number" id="minSupportInput" value="2000" min="1" /></label>
    </div>

    <div class="button-group">
      <button id="mineBtn" class="btn" disabled>Mine & Filter</button>
      <button id="groupBtn" class="btn" disabled>Group Patterns</button>
    </div>
  </div>

  <p id="mineStatus" class="status"></p>
  <canvas id="groupChart" width="600" height="300"></canvas>
  <div id="groupLabel" class="group-label"></div>
<div id="resultGrid" class="result-grid"></div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const statusMsg  = document.getElementById('statusMsg');
    const mineBtn    = document.getElementById('mineBtn');
    const groupBtn   = document.getElementById('groupBtn');
    const resultGrid = document.getElementById('resultGrid');

    fileInput.addEventListener('change', async () => {
      if (!fileInput.files.length) return;
      const file = fileInput.files[0];
      statusMsg.textContent = 'Uploading file...';
      const form = new FormData(); 
      form.append('file', file);
      const up = await fetch('/upload/', { method: 'POST', body: form });
      if (!up.ok) {
        statusMsg.textContent = 'Upload failed.';
        return;
      }
      statusMsg.textContent = 'Parsing CSV...';
      const text = await file.text();
      const lines = text.split(/\r?\n/).filter(l => l.trim());
      const header = lines[0].split(',');
      const fidIdx = header.indexOf('floor_id');
      const aidIdx = header.indexOf('apartment_id');
      if (fidIdx < 0 || aidIdx < 0) {
        statusMsg.textContent = 'Missing floor_id or apartment_id columns.';
        return;
      }
      const seen = new Set(), uniquePairs = [];
      for (const row of lines.slice(1)) {
        const cols = row.split(',');
        const floor = cols[fidIdx], apt = cols[aidIdx];
        if (!floor || !apt) continue;
        const key = `${floor}_${apt}`;
        if (!seen.has(key)) {
          seen.add(key);
          uniquePairs.push({ floor, apt });
          if (uniquePairs.length === 2000) break;
        }
      }
      statusMsg.textContent = `Processing ${uniquePairs.length} graph(s)...`;
      let count = 0;
      for (const {floor, apt} of uniquePairs) {
        const pr = await fetch(`/process/${floor}/${apt}`, { method: 'POST' });
        if (pr.ok) count++;
      }
      statusMsg.textContent = `Stored ${count}/${uniquePairs.length} graphs.`;
      mineBtn.disabled = false;
    });

    mineBtn.addEventListener('click', async () => {
      mineBtn.disabled = true;
      document.getElementById('mineStatus').textContent = 'Mining & filteringâ€¦';
      document.getElementById('groupChart').style.display = 'none';
      const params = new URLSearchParams({
        vcount:          document.getElementById('vcountInput').value,
        max_width:       document.getElementById('maxWidthInput').value,
        ratio_threshold: document.getElementById('ratioInput').value,
        min_support:     document.getElementById('minSupportInput').value
      });
      const res = await fetch(`/mine?${params}`, { method: 'POST' });
      const payload = await res.json();
      if (!res.ok) {
        document.getElementById('mineStatus').textContent = payload.detail || 'Error';
        mineBtn.disabled = false;
        return;
      }
      document.getElementById('mineStatus').textContent = `Found ${payload.patterns.length} patterns.`;
      resultGrid.innerHTML = '';
      for (const p of payload.patterns) {
        const card = document.createElement('div');
        card.className = 'result-card';
        const img = document.createElement('img');
        img.src = `/pattern/${p.gid}/image?rooms=${p.rooms.join(",")}`;
        img.alt = `pattern ${p.gid}`;
        card.appendChild(img);
        resultGrid.appendChild(card);
      }
      mineBtn.disabled = false;
      groupBtn.disabled = false;
    });

    groupBtn.addEventListener('click', async () => {
      groupBtn.disabled = true;
      document.getElementById('mineStatus').textContent = 'Grouping segment patterns...';

      const res = await fetch('/segments/grouped', { method: 'GET' });
      const { groups, sizes } = await res.json();
      const paired = groups.map((group, i) => ({ group, size: sizes[i] }));
      paired.sort((a, b) => b.size - a.size);
      // â¬‡ï¸ Keep only top 10 groups for pie chart
      const top10 = paired.slice(0, 10);
      const sortedGroups = top10.map(p => p.group);
      const sortedSizes = top10.map(p => p.size);
        
      const ctx = document.getElementById('groupChart').getContext('2d');
      document.getElementById('groupChart').style.display = 'block';
      if (window.groupPieChart) window.groupPieChart.destroy();

      window.groupPieChart = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: sortedGroups.map((_, i) => `Group ${i + 1}`),
          datasets: [{
            data: sortedSizes,
            backgroundColor: sortedGroups.map((_, i) =>
              `hsl(${(i * 360 / sortedGroups.length)}, 70%, 70%)`)
          }]
        },
        options: {
            onClick: async (evt, elements) => {
                if (!elements.length) return;
                const index = elements[0].index;

                // Update label
                document.getElementById('groupLabel').textContent = `Group ${index + 1}`;

                // Clear previous results
                resultGrid.innerHTML = '';

                try {
                // Fetch the single group
                const res = await fetch(`/segments/group/${index}`);
                if (!res.ok) throw new Error('Failed to fetch group');
                const { file_names } = await res.json();

                // Build a container for this group's images
                const rowGrid = document.createElement('div');
                rowGrid.className = 'row-grid';

                // Append each image
                file_names.forEach(fname => {
                    const gid = fname.replace('.pkl', '');
                    const card = document.createElement('div');
                    card.className = 'result-card';

                    const img = document.createElement('img');
                    img.src = `/pattern/from_pickle_subgraph/${encodeURIComponent(fname)}`;
                    img.alt = `pattern ${gid}`;

                    card.appendChild(img);
                    rowGrid.appendChild(card);
                });

                // Add to the page
                resultGrid.appendChild(rowGrid);

                } catch (err) {
                resultGrid.textContent = 'Failed to load group images.';
                console.error(err);
                }
            },

          plugins: {
            legend: { position: 'right', labels: { boxWidth: 14 } },
            title: {
              display: true,
              text: 'Segment Pattern Group Distribution',
              font: { size: 16 }
            }
          }
        }
      });

      resultGrid.innerHTML = '';
        sortedGroups.forEach((group, idx) => {
        const groupBlock = document.createElement('div');
        groupBlock.className = 'group-block';
        groupBlock.dataset.groupIndex = idx + 1;
        groupBlock.style.display = 'block';    // show it immediately

        const header = document.createElement('h3');
        header.textContent = `Group ${idx + 1}`;
        groupBlock.appendChild(header);

        const rowGrid = document.createElement('div');
        rowGrid.className = 'row-grid';

        // ðŸ”‘ here we loop the `group` variable we aliased earlier,
        //    not the unrelated file_names:
        group.forEach(fname => {
            const card = document.createElement('div');
            card.className = 'result-card';
            const img = document.createElement('img');
            img.src = `/pattern/from_pickle_subgraph/${encodeURIComponent(fname)}`;
            img.alt = fname;
            card.appendChild(img);
            rowGrid.appendChild(card);
        });

        groupBlock.appendChild(rowGrid);
        resultGrid.appendChild(groupBlock);
        });

      document.getElementById('mineStatus').textContent = `Grouped into ${groups.length} categories (ranked).`;
      groupBtn.disabled = false;
    });

    document.getElementById('connectBtn').addEventListener('click', async () => {
        document.getElementById('statusMsg').textContent = 'Connecting to existing database...';
        const res = await fetch('/connect_existing', { method: 'POST' });
        const data = await res.json();
        document.getElementById('statusMsg').textContent = data.message;

        // Enable mining and grouping
        mineBtn.disabled = false;
        groupBtn.disabled = false;

        // Optionally disable upload to prevent reprocessing
        fileInput.disabled = true;
        });
  </script>
</body>
</html>
