<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Module Platform Builder</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
    /* ----------------------
       1) Global & reset
       ---------------------- */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f7fa;
      color: #333;
      margin: 2rem;
      display: flex;
      flex-direction: column;
    }
    h1 {
      text-align: center;
      font-size: 2rem;
      margin-bottom: 1.5rem;
    }

    /* ----------------------
       2) Controls bar
       ---------------------- */
    .controls-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      justify-content: center;
      margin-bottom: 1.5rem;
    }
    .btn, .file-label {
      padding: 0.6rem 1.2rem;
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s;
      font-size: 1rem;
    }
    .btn:hover:not(:disabled),
    .file-label:hover {
      background-color: #0056b3;
    }
    input[type="file"] { display: none; }
    input[type="number"], input[type="text"] {
      padding: 0.4rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      text-align: center;
    }
    input[type="text"] { text-align: left; }
    .status {
      width: 100%;
      text-align: center;
      font-size: 0.95rem;
      color: #555;
      margin: 0.5rem 0;
    }

    /* ----------------------
       3) Main three-column layout
       ---------------------- */
    #main-container {
      flex: 1;
      display: flex;
      gap: 20px;
      overflow-x: hidden;
      margin-bottom: 2rem;
    }

    /* shared panel styles */
    #results-panel,
    #search-panel,
    #chart-panel {
      flex: 1;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
    }

    /* ----------------------
       4) Left panel: mine results
       ---------------------- */
    #results-panel {
      overflow-y: auto;
    }
    #results-panel > button {
      align-self: start;
      width: auto;
      margin-bottom: 0.5rem;
    }
    #resultsGrid {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
      margin-top: 0.5rem;
    }
    .result-card {
      width: 280px;
      height: 200px;
      border: 1px solid #ccc;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    }
    .result-card img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    /* ----------------------
       5) Middle panel: search
       ---------------------- */
    #search-panel .controls {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    #search-panel input[type="text"] {
      flex: 1;
      text-align: left;
    }
    #searchResultsGrid {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
      margin-top: 0.5rem;
      overflow-y: auto;
    }

    /* ----------------------
       6) Right panel: charts & image
       ---------------------- */
    #chart-panel {
      align-items: center;
      gap: 1rem;
      overflow-y: auto;
    }
    #chart-panel > button {
      align-self: start;
      width: auto;
    }
    .chart-wrapper {
      width: 100%;
      max-width: 400px;
      height: 300px;
      margin: 0 auto;
      position: relative;
    }
    .chart-wrapper canvas,
    .chart-wrapper img {
      display: block;
      width: 100% !important;
      height: 100% !important;
      object-fit: contain;
    }
    /* combo panel tweaks */
    #combo-panel.chart-wrapper {
      display: flex !important;
      flex-direction: column;
      align-items: center;
      margin-top: 3rem;
      height: 360px !important;
    }
    #combo-panel.chart-wrapper canvas {
      height: calc(100% - 1.5rem) !important;
      margin-top: 1.5rem;
    }

    /* hide example panels until used */
    #example-panel,
    #selectedCase,
    #combo-panel {
      display: none;
    }
  </style>
</head>
<body>
  <h1>Module Platform Builder</h1>

  <div class="controls-container">
    <label class="file-label" for="fileInput">Upload CSV</label>
    <input type="file" id="fileInput" accept=".csv" />
    <label>Rooms: <input type="number" id="vcountInput" value="4" min="1" /></label>
    <label>Max width: <input type="number" id="maxWidthInput" step="0.1" value="2.5" /></label>
    <label>Compactness: <input type="number" id="ratioInput" step="0.01" value="0.3" /></label>
    <label>Min support: <input type="number" id="minSupportInput" value="2000" /></label>
    <p id="statusMsg" class="status">Awaiting file.</p>
  </div>

  <div id="main-container">
    <!-- LEFT PANEL: Mine & Filter Results -->
    <div id="results-panel">
      <button id="mineBtn" class="btn" disabled>Mine & Filter</button>
      <div id="resultsGrid"></div>
    </div>

    <!-- MIDDLE PANEL: Search by Room Combo -->
    <div id="search-panel">
      <div class="controls">
        <input type="text" id="comboInput" placeholder="e.g. Bathroom + Corridor + Kitchen" />
        <button id="searchBtn" class="btn" disabled>Search</button>
      </div>
      <div id="searchResultsGrid"></div>
      <button id="groupSearchBtn" class="btn" disabled>Group Search</button>
      <div id="searchChartContainer" class="chart-wrapper" style="display:none; margin-top:1rem;">
        <canvas id="searchChart"></canvas>
      </div>
    </div>

    <!-- RIGHT PANEL: Group & Example Display -->
    <div id="chart-panel">
      <button id="groupBtn" class="btn" disabled>Group Patterns</button>
      <div id="chart-container" class="chart-wrapper">
        <canvas id="groupChart"></canvas>
      </div>

      <div id="example-panel" style="flex-direction:column; align-items:center; gap:1rem;">
        <div id="selectedCase" class="chart-wrapper"></div>
        <div id="combo-panel" class="chart-wrapper" style="flex-direction:column; align-items:center;">
          <h4 style="margin:0.5rem 0;">Room-type combo distribution</h4>
          <canvas id="comboChart"></canvas>
        </div>
      </div>
    </div>
  </div>


  <script>
    const fileInput   = document.getElementById('fileInput');
    const statusMsg   = document.getElementById('statusMsg');
    const mineBtn     = document.getElementById('mineBtn');
    const groupBtn    = document.getElementById('groupBtn');
    const resultsGrid = document.getElementById('resultsGrid');
    const comboInput       = document.getElementById('comboInput');
    const searchBtn        = document.getElementById('searchBtn');
    const searchResultsGrid= document.getElementById('searchResultsGrid');
    let mineResults   = [];
    let groupData     = { groups: [], sizes: [] };


    // File‐upload + initial processing
    fileInput.addEventListener('change', async () => {
      if (!fileInput.files.length) return;
      const file = fileInput.files[0];
      statusMsg.textContent = 'Uploading file...';
      const form = new FormData(); 
      form.append('file', file);
      const up = await fetch('/upload/', { method: 'POST', body: form });
      if (!up.ok) {
        statusMsg.textContent = 'Upload failed.';
        return;
      }
      statusMsg.textContent = 'Parsing CSV...';
      const text = await file.text();
      const lines = text.split(/\r?\n/).filter(l => l.trim());
      const header = lines[0].split(',');
      const fidIdx = header.indexOf('floor_id');
      const aidIdx = header.indexOf('apartment_id');
      if (fidIdx < 0 || aidIdx < 0) {
        statusMsg.textContent = 'Missing floor_id or apartment_id columns.';
        return;
      }
      const seen = new Set(), uniquePairs = [];
      for (const row of lines.slice(1)) {
        const cols = row.split(',');
        const floor = cols[fidIdx], apt = cols[aidIdx];
        if (!floor || !apt) continue;
        const key = `${floor}_${apt}`;
        if (!seen.has(key)) {
          seen.add(key);
          uniquePairs.push({ floor, apt });
          // if (uniquePairs.length === 1000) break;
        }
      }
      statusMsg.textContent = `Processing ${uniquePairs.length} graph(s)...`;
      let count = 0;
      for (const {floor, apt} of uniquePairs) {
        const pr = await fetch(`/process/${floor}/${apt}`, { method: 'POST' });
        if (pr.ok) count++;
      }
      statusMsg.textContent = `Stored ${count}/${uniquePairs.length} graphs.`;
      mineBtn.disabled = false;
    });

    

    // Mining endpoint
    mineBtn.addEventListener('click', async () => {
      mineBtn.disabled = true;
      statusMsg.textContent = 'Mining & filtering…';
      const params = new URLSearchParams({
        vcount:          document.getElementById('vcountInput').value,
        max_width:       document.getElementById('maxWidthInput').value,
        ratio_threshold: document.getElementById('ratioInput').value,
        min_support:     document.getElementById('minSupportInput').value
      });
      const res = await fetch(`/mine?${params}`, { method: 'POST' });
      const payload = await res.json();
      if (!res.ok) {
        statusMsg.textContent = payload.detail || 'Error';
        mineBtn.disabled = false;
        return;
      }
      mineResults = payload.patterns;
      statusMsg.textContent = `Found ${mineResults.length} patterns.`;

      window.enrichedPatterns = payload.patterns;
      // now that we have patterns, enable the search button
      searchBtn.disabled = false;
      resultsGrid.innerHTML = '';
      mineResults.forEach(p => {
        const card = document.createElement('div');
        card.className = 'result-card';
        const img = document.createElement('img');
        img.src = `/pattern/${p.gid}/image?rooms=${p.rooms.join(',')}`;
        img.alt = `pattern ${p.gid}`;
        card.appendChild(img);
        resultsGrid.appendChild(card);
      });
      mineBtn.disabled = false;
      groupBtn.disabled = false;
    });


    searchBtn.addEventListener('click', () => {
  console.log('Search clicked, looking for:', comboInput.value);
  const wanted = comboInput.value
    .split('+').map(s => s.trim()).filter(Boolean)
    .sort().join('+');

  // Clear old grid
  searchResultsGrid.innerHTML = '';

  // Find all entries matching that combo
  const matches = window.enrichedPatterns.filter(e => e.combo === wanted);

  // Populate grid
  matches.forEach(entry => {
    const card = document.createElement('div');
    card.className = 'result-card';
    const img = document.createElement('img');
    img.src = `/pattern/from_pickle_subgraph/${encodeURIComponent(entry.file)}`;
    img.alt = entry.combo;
    card.appendChild(img);
    searchResultsGrid.appendChild(card);
  });

  // Enable grouping if we have any matches
  const groupBtn = document.getElementById('groupSearchBtn');
  if (matches.length > 0) {
    groupBtn.disabled = false;
    document.getElementById('searchChartContainer').style.display = 'block';
  } else {
    groupBtn.disabled = true;
  }
});

// Group‐by‐pattern handler
let searchChart = null;
document.getElementById('groupSearchBtn')
  .addEventListener('click', () => {
    const wanted = comboInput.value
      .split('+').map(s=>s.trim()).filter(Boolean)
      .sort().join('+');

    // Re‐filter to be safe
    const matches = window.enrichedPatterns.filter(e => e.combo === wanted);

    // Count per topology (entry.pattern)
      const counts = matches.reduce((acc, e) => {
  acc[e.hash] = (acc[e.hash] || 0) + 1;
  return acc;
}, {});

// 2) convert to array and sort descending
let buckets = Object.entries(counts)
  .map(([hash, cnt]) => ({ hash, cnt }))
  .sort((a, b) => b.cnt - a.cnt);

// 3) split top 10 and the rest
const topN = 10;
const topBuckets = buckets.slice(0, topN);
const otherBuckets = buckets.slice(topN);

// 4) prepare labels & data
const labels = topBuckets.map(b => b.hash);
const data   = topBuckets.map(b => b.cnt);

// if (otherBuckets.length) {
//   const otherCount = otherBuckets.reduce((sum, b) => sum + b.cnt, 0);
//   labels.push('Others');
//   data.push(otherCount);
// }

// 5) draw/destroy chart as before
const colors = labels.map((_, i) =>
  `hsl(${i * 360 / labels.length}, 60%, 60%)`
);

const ctx = document.getElementById('searchChart').getContext('2d');
if (searchChart) searchChart.destroy();

searchChart = new Chart(ctx, {
  type: 'pie',
  data: {
    labels,
    datasets: [{
      data,
      backgroundColor: colors    // <-- use the array you just made
    }]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'right',
        title: { display: true, text: 'Module Hashes' }
      }
    },
    onClick: (evt, elems) => {
      if (!elems.length) return;
      const idx = elems[0].index;
      const chosen = labels[idx];

      let filtered;
      if (chosen === 'Others') {
        const topHashes = topBuckets.map(b => b.hash);
        filtered = matches.filter(e => !topHashes.includes(e.hash));
      } else {
        filtered = matches.filter(e => e.hash === chosen);
      }

      // redraw the grid
      searchResultsGrid.innerHTML = '';
      filtered.forEach(entry => {
        const card = document.createElement('div');
        card.className = 'result-card';
        const img = document.createElement('img');
        img.src = `/pattern/from_pickle_subgraph/${encodeURIComponent(entry.file)}`;
        img.alt = entry.combo;
        card.appendChild(img);
        searchResultsGrid.appendChild(card);
      });
    }
  }
});
  });

    let chart             = null;
    let comboChartInstance = null;

      groupBtn.addEventListener('click', async () => {
    // 1) fetch the grouped filenames & sizes
    const resp = await fetch('/segments/grouped');
    const { groups: srvGroups, sizes: srvSizes } = await resp.json();

    // 2) build & sort {size, files} array
    const idxArr = srvSizes
      .map((sz,i) => ({ size: sz, files: srvGroups[i] }))
      .sort((a,b) => b.size - a.size);

    // 3) top 10 + “Other”
    const topN = 10;
    const top  = idxArr.slice(0, topN);
    const rest = idxArr.slice(topN);

    // 4) labels & data
    const labels = top.map((_,i) => `Group ${i+1}`);
    const data   = top.map(g => g.size);

    // 5) map filenames → full mineResults entries
    const mappedGroups = top.map(g =>
      g.files
       .map(fn => {
         // strip “.pkl” then split off the trailing "_UUID"
         const bare = fn.replace(/\.pkl$/, '');
         const idx  = bare.lastIndexOf('_');
         const gid  = bare.substring(0, idx);
         const rec  = mineResults.find(p => p.gid === gid);
         return rec
           ? { ...rec, file: fn }
           : null;
       })
       .filter(Boolean)
    );

    if (rest.length) {
      labels.push('Other');
      data.push(rest.reduce((sum,g) => sum + g.size, 0));
      mappedGroups.push(
        rest.flatMap(g =>
          g.files
           .map(fn => {
             const bare = fn.replace(/\.pkl$/, '');
             const idx  = bare.lastIndexOf('_');
             const gid  = bare.substring(0, idx);
             const rec  = mineResults.find(p => p.gid === gid);
             return rec
               ? { ...rec, file: fn }
               : null;
           })
           .filter(Boolean)
        )
      );
    }

    // 6) store into groupData
    groupData.groups = mappedGroups;
    groupData.sizes  = data;

    console.log("groupData.groups after mapping:", groupData.groups);
    console.log("groupData.sizes  after mapping:", groupData.sizes);

    // 7) draw the top‐level pie
    const ctx = document.getElementById('groupChart').getContext('2d');
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'pie',
      data: { labels, datasets:[{ data, hoverOffset:10, offset:new Array(data.length).fill(0) }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        onClick: (evt, elems) => {
          if (!elems.length) return;
          const idx = elems[0].index;
          if (idx >= groupData.groups.length) return;
          chart.data.datasets[0].offset =
            data.map((_,i)=> i===idx ? 20 : 0);
          chart.update();
          showOneCase(idx);
        }
      }
    });

    document.getElementById('main-container').style.display = 'flex';
  });




async function showOneCase(idx) {
  const entries = groupData.groups[idx];
  if (!entries || !entries.length) return;

  // 1) reveal the example‐panel
  const panel = document.getElementById('example-panel');
  panel.style.display = 'flex';

  // 2) inject the image
  const { file, pattern } = entries[0];
  document.getElementById('selectedCase').innerHTML =
    `<img src="/pattern/from_pickle_subgraph/${encodeURIComponent(file)}" />`;
  document.getElementById('selectedCase').style.display = 'block';

  // 3) fetch combos…
  const gidList = entries.map(e=>e.gid).join(',');
  const resp    = await fetch(
    `/pattern/combos/?pattern=${encodeURIComponent(pattern)}&gids=${encodeURIComponent(gidList)}`
  );
  const combos  = await resp.json();

  // 4) prepare data
  const labels = combos.map(c=>c.combo.join(' + '));
  const data   = combos.map(c=>c.count);

  // 5) show & draw the combo pie
  document.getElementById('combo-panel').style.display = 'block';
  const ctx = document.getElementById('comboChart').getContext('2d');
  if (window.comboChartInstance) window.comboChartInstance.destroy();
  window.comboChartInstance = new Chart(ctx, {
    type: 'pie',
    data: { labels, datasets:[{ data, backgroundColor: labels.map((_,i)=>`hsl(${i*360/labels.length},60%,60%)` ) }] },
    options: { responsive:true, maintainAspectRatio:false }
  });
}
    // // Grouping + reveal layout
    // groupBtn.addEventListener('click', async () => {
    // const resp = await fetch('/segments/grouped');
    // groupData = await resp.json();
    // const ctx = document.getElementById('groupChart').getContext('2d');

    // // Sort groups by size descending
    // const indexed = groupData.sizes.map((size, i) => ({
    // size,
    // files: groupData.groups[i]
    // }));
    // indexed.sort((a, b) => b.size - a.size);

    // const topN = 10;
    // const topGroups = indexed.slice(0, topN);
    // const otherGroups = indexed.slice(topN);

    // // Labels will be reassigned as Group 1 to Group 10 based on size
    // const labels = topGroups.map((_, i) => `Group ${i + 1}`);
    // const data = topGroups.map(g => g.size);
    // const topGroupFiles = topGroups.map(g => g.files);

    // // Add "Other" group if applicable
    // if (otherGroups.length > 0) {
    // labels.push("Other");
    // data.push(otherGroups.reduce((sum, g) => sum + g.size, 0));
    // topGroupFiles.push(otherGroups.flatMap(g => g.files));
    // }

    // // Update groupData.groups with reordered + grouped files
    // groupData.groups = topGroupFiles;

    // // Destroy old chart
    // if (chart) chart.destroy();

    // chart = new Chart(ctx, {
    // type: 'pie',
    // data: {
    //     labels: labels,
    //     datasets: [{
    //     data: data,
    //     hoverOffset: 10,
    //     offset: new Array(data.length).fill(0)
    //     }]
    // },
    // options: {
    //     responsive: true,
    //     maintainAspectRatio: false,
    //     onClick: (evt, elems) => {
    //     if (!elems.length) return;
    //     const idx = elems[0].index;

    //     // Skip "Other" (last index) if clicked
    //     if (idx >= topN) return;

    //     chart.data.datasets[0].offset = data.map((_, i) => (i === idx ? 20 : 0));
    //     chart.update();
    //     showOneCase(idx);
    //     }
    // }
    // });


    // // reveal panels…
    // document.getElementById('main-container').style.display = 'flex';
    // });


    // // Display single example
    // function showOneCase(groupIndex) {
    //   const fileList = groupData.groups[groupIndex];
    //   if (!fileList.length) return;
    //   const filename = fileList[1];
    //   const sel = document.getElementById('selectedCase');
    //   sel.innerHTML = '';
    //   const img = document.createElement('img');
    //   img.src = `/pattern/from_pickle_subgraph/${encodeURIComponent(filename)}`;
    //   sel.appendChild(img);
    // }
  </script>
</body>
</html>
